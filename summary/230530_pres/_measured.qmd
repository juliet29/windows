# Analysis: Measurements 


## Simulation vs Measurements  
<!-- TODO: real vs observed data   -->
```{python}

a00, a01 = h.import_desired_data("A", "15T")

w1 = wd2.Window_Detect2(a01)
w1.analyze_window_change(wd2.make_stl_smooth)

```

```{python}

all_names = ["Window", "Observed Temp", "Smoothed", "Difference", "Deriv1", "Deriv2"]
all_traces = ["window_norm", "temp_norm", "smooth_series", "dif", "deriv", "deriv2"]

fig, names = wd2.make_dual_plot_abstract(time=w1.time, objects=[s1, w1], names=all_names, traces=all_traces, title_arr=["Simulation", "Measurement"], )

fig = wd2.update_dual_plot(fig,  names, ["Window", "Observed Temp"],)
fig.show()

# def show_double_fig(trace, obj1=s1, obj2=w1):
#     fig1 = show_single_trace(obj1, trace, showlegend=False, width=480)
#     fig1.show()
#     fig2 = show_single_trace(obj2, trace, width=500)
#     fig2.show()

# show_double_fig("Observed Temp")
```

## Smoothing with STL
<!-- TODO: STL figure-->


```{python}


fig = wd2.update_dual_plot(fig,  names, ["Window", "Smoothed"],)
fig.show()
# show_double_fig("Smoothed")
```

## Difference
```{python}

# show_double_fig("Difference")

fig = wd2.update_dual_plot(fig,  names, ["Window", "Difference"],)
fig.show()
```

## Derivatives 
```{python}

# show_double_fig("Deriv1")

fig = wd2.update_dual_plot(fig,  names, ["Window", "Deriv1", "Deriv2"],)
fig.show()

```

<!-- ## Derivatives

```{python}
#| layout-ncol: 2
show_double_fig("Deriv2")

``` -->

## Making Predictions 
::: {.r-stack}

```{python}
#| output-location: fragment

fig = wd2.plot_many_dist([s1, w1], ["Simulation", "Measuerement",])
fig = fig.update_layout(autosize=False, width=1000, height=500,)
fig.show()

```

::: {.fragment}
```{python}
#| output-location: fragment

fig, names = wd2.make_dual_plot_abstract(time=w1.time, objects=[s1, w1,], names=["Window", "Z-Score 1", "Z-Score 2", "Guesses ~ Z-Score 1 > 2"], traces=["window_norm", "zscore", "zscore2", "guess_values"], title_arr=["Simulation", "Measurement"], mode=["lines", "lines", "lines", "markers"])
fig = fig.update_layout(autosize=False, width=1000, height=500)

fig = wd2.update_dual_plot(fig,  names, ["Window", "Z-Score 1", ],)
fig.show()
```
:::

::: {.fragment}
```{python}
#| output-location: fragment

fig = wd2.update_dual_plot(fig,  names, ["Window", "Z-Score 1", "Z-Score 2", ],)
fig.show()
```
:::


::: {.fragment}
```{python}
#| output-location: fragment

fig = wd2.update_dual_plot(fig,  names, ["Window", "Z-Score 1", "Z-Score 2", "Guesses ~ Z-Score 1 > 2"],)
fig.show()
```
:::



:::



## Other Smoothing Techniques 
- Fitting a sinusoid 
- Modifying the STL technique?
- Exponentially weighted mean function 

## Other Smoothing Techniques 
<!-- TODO: othe rsmoothing technique figures -->

::: {.r-stack}
```{python}

w2 = wd2.Window_Detect2(a01)
w2.analyze_window_change(wd2.make_sin_smooth)

w3 = wd2.Window_Detect2(a01)
w3.analyze_window_change(wd2.make_ewm_smooth)

fig, names = wd2.make_dual_plot(w2.time, w2, w3, ["Sinusoid", "EWM"])
fig = fig.update_layout(autosize=False, width=1000, height=500,)

fig1 = wd2.update_dual_plot(fig,  names, ["Window", "Observed Temp", "Smoothed"],)

fig1.show()

```

::: {.fragment}
```{python}

fig1 = wd2.update_dual_plot(fig,  names, ["Window", "Deriv1",],)

fig1.show()
```
:::


:::


## Comparing Results 
```{python}
#| layout-row: 2

fig = wd2.plot_many_dist([w1, w2, w3], ["STL", "Sinusoid", "EWM"])
fig = fig.update_layout(autosize=False, width=1000, height=300,)
fig.show()

fig1, names = wd2.make_dual_plot_abstract(time=w1.time, objects=[w1, w2, w3], names=["Window", "Z-Score", "Guesses"], traces=["window_norm", "zscore_norm", "guess_values"], title_arr=["", "", ""], mode=["lines", "lines", "markers"])
fig1 = fig1.update_layout(autosize=False, width=1000, height=300)
fig1.show()


```
<!-- table TODO: de raultin de roy metrics + compare to other ML methods on same data  -->


## Metrics 


## reflections 
- better understanding the unique way that w/o/c appears in the time series
  - how this differs 
    - based on time of day 
    - length of w/o/c
  - can use BEM + CFD for this?
- when sort of smoothing method is truly best for this use case?
- test on larger external data set 
<!-- TODO: progress on cfd so far?  -->